from flask import Flask, render_template, request, jsonify, send_from_directory
from flask_cors import CORS
import pefile
import pandas as pd
import datetime
import os
import joblib
import traceback

app = Flask(__name__)
CORS(app)

your_trained_model = joblib.load('logreg_model.joblib')

def extract_all_features(file_path):
    pe = pefile.PE(file_path)
    features = {'e_cblp': pe.DOS_HEADER.e_cblp, 'e_cp': pe.DOS_HEADER.e_cp, 'e_cparhdr': pe.DOS_HEADER.e_cparhdr,
                'e_maxalloc': pe.DOS_HEADER.e_maxalloc, 'e_sp': pe.DOS_HEADER.e_sp, 'e_lfanew': pe.DOS_HEADER.e_lfanew,
                'NumberOfSections': pe.FILE_HEADER.NumberOfSections,}
    creation_time = datetime.datetime.utcfromtimestamp(pe.FILE_HEADER.TimeDateStamp)
    features['CreationYear'] = creation_time.year
    for char_num, char in enumerate(pe.DOS_HEADER.e_res):
        features[f'FH_char{char_num}'] = char
    features['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
    features['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
    features['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
    features['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
    features['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
    features['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    features['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
    features['BaseOfData'] = pe.OPTIONAL_HEADER.BaseOfData
    features['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
    features['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
    features['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment
    features['MajorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
    features['MinorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
    features['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion
    features['MinorImageVersion'] = pe.OPTIONAL_HEADER.MinorImageVersion
    features['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
    features['MinorSubsystemVersion'] = pe.OPTIONAL_HEADER.MinorSubsystemVersion
    features['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
    features['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
    features['CheckSum'] = pe.OPTIONAL_HEADER.CheckSum
    features['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
    for char_num, char in enumerate(pe.OPTIONAL_HEADER.DllCharacteristics.to_bytes(11, byteorder='big')):
        features[f'OH_DLLchar{char_num}'] = char
    features['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve
    features['SizeOfStackCommit'] = pe.OPTIONAL_HEADER.SizeOfStackCommit
    features['SizeOfHeapReserve'] = pe.OPTIONAL_HEADER.SizeOfHeapReserve
    features['SizeOfHeapCommit'] = pe.OPTIONAL_HEADER.SizeOfHeapCommit
    features['LoaderFlags'] = pe.OPTIONAL_HEADER.LoaderFlags
    sus_sections = 0
    non_sus_sections = 0
    for section in pe.sections:
        if section.Characteristics & 0xE0000000:
            sus_sections += 1
        else:
            non_sus_sections += 1
    features['sus_sections'] = sus_sections
    features['non_sus_sections'] = non_sus_sections
    features['packer'] = 0
    features['E_text'] = pe.sections[0].SizeOfRawData if pe.sections else 0
    features['E_data'] = pe.sections[1].SizeOfRawData if len(pe.sections) > 1 else 0
    features['filesize'] = os.path.getsize(file_path)
    features['E_file'] = 0
    features['fileinfo'] = 0
    features['pt_num'] = 0
    return features

@app.route('/static/<path:filename>')
def serve_static(filename):
    return send_from_directory('static', filename)

@app.route('/')
def index():
    return render_template('newfrontend.html')

@app.route('/check_file', methods=['POST'])
def check_file():
    try:
        if 'file' not in request.files:
            return jsonify({'error': 'No file part'})

        file = request.files['file']

        if file.filename == '':
            return jsonify({'error': 'No selected file'})

        if file:
            temp_file_path = 'temp_uploaded_file'
            file.save(temp_file_path)
            file_features = extract_all_features(temp_file_path)
            os.remove(temp_file_path)
            df_to_check = pd.DataFrame([file_features])
            prediction = your_trained_model.predict(df_to_check)
            print(f"File checked. Prediction: {prediction}")

            # Return a JSON response with the 'result' key
            if prediction[0] == 1:
                return jsonify({'result': 'The file is predicted as malicious.'})
            else:
                return jsonify({'result': 'The file is predicted as benign.'})

    except Exception as e:
        traceback.print_exc()  # Print the traceback to the console for debugging
        return jsonify({'error': f'Error checking file: {str(e)}'})

if __name__ == '__main__':
    app.run(debug=True) 